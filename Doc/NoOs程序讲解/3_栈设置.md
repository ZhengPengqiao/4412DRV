# 3_栈设置

## 执行结果

* 小灯闪烁速度大概是4秒(一灭一亮)

## 解释说明

* 裸机程序 2_leds_s_wtd 可以正常执行, 可以看到4个LED灯正常闪烁，说明手动关闭看门狗成功，同时证明IROM中的固化代码已经设置了栈。
* 为什么程序成功调用C函数就说明了IROM的固化代码设置了栈呢？
  * 是因为汇编中调用C函数时，参数的传递、现场的保存和恢复、临时变量的保存等都需要使用到栈，在delay()函数中变量count就是临时变量，程序运行成功说明栈已经设置好了.
* 如果在DDR没有初始化时想使用C语言, 需要将sp设置在iRAM中.应注意iRAM地址范围.
  * iRAM ：内部内存区，加载通过OM选择后的启动程序，通常加载bl1、bl2
  * 地址范围: 0x02020000~0x02060000

* 为什么调用C函数要设置栈
* 栈的整体作用
  * 保存现场；
    * 现场，意思就相当于案发现场，总有一些现场的情况，要记录下来的，否则被别人破坏掉之后，你就无法恢复现场了。而此处说的现场，就是指CPU运行的时候，用到了一些寄存器，比如r0,r1等等，对于这些寄存器的值，如果你不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来(入栈push)，等调用函数执行完毕返回后(出栈pop)，再恢复现场。这样CPU就可以正确的继续执行了。保存寄存器的值，一般用的是push指令，将对应的某些寄存器的值，一个个放到栈中，把对应的值压入到栈里面，即所谓的压栈。然后待被调用的子函数执行完毕的时候，再调用pop，把栈中的一个个的值，赋值给对应的那些你刚开始压栈时用到的寄存器，把对应的值从栈中弹出去，即所谓的出栈。其中保存的寄存器中，也包括lr的值（因为用bl指令进行跳转的话，那么之前的PC的值是存在lr中的），然后在子程序执行完毕的时候，再把栈中的lr的值pop出来，赋值给PC，这样就实现了子函数的正确的返回。
  * 传递参数:汇编代码调用C函数时，需传递参数；
    * C语言进行函数调用的时候，常常会传递给被调用的函数一些参数，对于这些C语言级别的参数，被编译器翻译成汇编语言的时候，就要找个地方存放一下，并且让被调用的函数能够访问，否则就没发实现传递参数了。对于找个地方放一下，分两种情况。一种情况是，本身传递的参数不多于4个，就可以通过寄存器r0~r3传送参数。因为在前面的保存现场的动作中，已经保存好了对应的寄存器的值，那么此时，这些寄存器就是空闲的，可以供我们使用的了，那就可以放参数。另一种情况是，参数多于4个时，寄存器不够用，就得用栈了。
  * 保存临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量；
    * 包括函数的非静态局部变量以及编译器自动生成的其他临时变量。